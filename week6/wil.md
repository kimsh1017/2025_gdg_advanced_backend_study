## Ch.4 Implementing B-Trees

---

이전 챕터에선 Binary format의 일반적 원칙에 대해 설명했다. 또 셀을 구성하고, 계층 구조를 만들고 포인터를 사용해 페이지지와 셀을 연결하는 방법에 대해 배웠다. 이 개념은 in-place update 구조와 append-only 구조 모두 적용이 가능하다. 이번 챕터에선 B-Tree에 관련된 구체적인 개념을 짚고 갈 예정이다.

이 장의 내용은 3개의 그룹으로 나뉜다. 

- 구조 : 키와 포인터 사이의 관계를 설립하는 방법, 페이지 헤더와 페이지간 링크 구현 방법
- 루트에서 리프로 하강하는 과정 : 이진 탐색 수행과 병합, 분할을 위한 조회 경로 수집
- 최적화 기술 : 리밸런싱, right-only appends, bulk loading, 유지보수 과정, GC 등

## Page Header

---

페이지 헤더에는 탐색, 유지보수, 최적화 등에 사용 가능한 페이지 정보들이 들어있다. 일반적으로 다음 내용을 기록하는 플래그들을 포함한다. (페이지 내용과 레이아웃, 셀 개수, 빈 공간을 마킹하는 upper offset, lower offset, 기타 등등 유용한 메타데이터)

예를 들어 PostgreSQL은 페이지 크기, 레이아웃 버전을 헤더에 기록한다. InnoDB는 힙 레코드의 수, 레벨, 구현별 특정한 값을 저장한다. SQLite에선 셀의 수와 가장 오른쪽 포인터를 저장한다.

- InnoDB, PostgreSQL, SQLite의 페이지 헤더 구조
    
    

### Magic Number

파일 또는 페이지 헤더에 자주 포함되는 값 중 하나는 매직 넘버이다. 일반적으로 해당 블록이 페이지임을 나타내는 신호, 페이지 종류, 버전 등을 명시하는 상수 값으로 구성된 멀티 바이트 블록이다.

- DB별 매직넘버 구현
    
    SQLite :  모든 유효한 디비 파일은 다음 16 바이트로 시작한다. `53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00`  = “SQLite format 3\0”
    
    InnoDB : 직접적인 매직 넘버를 사용하지는 않음? 바이너리 로그 파일은 매직 넘버가 존재
    
    Berkeley DB : 버전 별로 다른 매직 넘버 사용
    

매직넘버는 종종 validation, sanity check(손상 여부 검증)에 사용된다. 랜덤 오프셋의 바이트 시퀀스가 매직넘버와 정확하게 일치하는 것은 거의 불가능하다. 만약 매직넘버가 일치한다면 오프셋이 정확하게 계산되고 있을 가능성이 매우 높다. 페이지가 올바르게 로드되고 정렬되었는지 확인하기 위해 페이지 헤더에 16진수 `50 41 47 45` 를 넣을 수 있다. 읽기 과정에서 헤더의 4 바이트를 해당 시퀀스와 비교하여 유효성 검사를 진행한다.

결론은? 

- 파일 형식 식별 : 파일 시작 부분에서 빠르게 식별 가능
- 무결성 검증 : 손상 여부 감지
- 버전 확인

등의 기능을 할 수 있다.

### Sibiling Link

몇몇 구현은 왼쪽 혹은 오른쪽 형제 페이지를 가리키는 forward, backward 링크를 저장한다. 이 링크들은 부모 노드를 다시 불러오지 않고도 앞 뒤 이웃 노드에 방문할 수 있게 해준다. 이러한 방식은 병합 및 분할 과정에서 형제 노드의 오프셋도 수정해야 하는 복잡성을 추가한다. 예를 들어 가장 오른쪽 노드가 아닌 노드가 분할된다면, 오른쪽 형제 노드의 backward 포인터(이전 노드를 가리키는 포인터) 는 새롭게 생성된 노드를 가리키도록 수정되어야 한다.

![image1.png](attachment:2448f301-d456-4a53-afcf-3a9e7f938f47:스크린샷_2025-06-01_오후_2.28.28.png)

형제 노드가 연결되어 있지 않다면, 형제 노드를 찾기 위해 그림 (a)처럼 부모 노드를 참조해야 한다. 자식 노드의 포인터만 가질 수 있기 때문에 운 안좋으면 루트 노드까지 올라갔다 와야만 한다. 형제 링크를 헤더에 같이 저장하면 같은 레벨 이웃 노드를 쉽게 찾을 수 있다.

대신 단점으로 분할, 병합 시 링크를 업데이트 해야한다. 업데이트는 분할, 병합되는 노드 뿐 아니라 형제 노드에서도 이루어져야 하므로 추가적인 락이 필요할 수 있다. concurrent B-Tree에서 형제 노드가 어떻게 유용하게 사용될 수 있는지에 대해선 나중에 다시 설명 예정

### Rightmost Pointers

B-Tree의 구분 키는 트리를 하위 트리로 분할, 탐색하는데 사용된다. 따라서 항상 포인터 수는 구분 키 + 1개이다. 

![image2.png](attachment:dd7407f8-6de4-46f9-8473-768470c0e5aa:스크린샷_2025-06-01_오후_3.41.48.png)

대부분의 구현에서 노드는 위의 그림에 더 가깝다. 각 키별로 하위 포인터가 있고, 가장 오른쪽 포인터는 어떤 키에도 매칭되지 않기 때문에 별도로 저장된다. 

이런 추가 포인터는 헤더에도 저장되기도 한다. (ex SQLite)

![image3.png](attachment:377bf71c-b695-4ff0-bb82-fbfe24d40fdc:스크린샷_2025-06-01_오후_3.09.28.png)

가장 오른쪽 자식이 분할되고, 세 셀이 부모에 추가되는 경우 가장 오른쪽 자식 포인터를 다시 할당해야 한다. 분할 후 부모에 추가된 셀(회색)은 새로운 키를 보유하고 분할된 노드를 가리킨다. 이전에 가장 오른쪽에 있던 포인터 대신 새 노드에 대한 포인터가 할당된다. 이런 비슷한 접근 방식이 SQLite에 설명,구현되어 있다.

![image4.png](attachment:bfac7730-552b-4283-b858-c3487ef98139:스크린샷_2025-06-13_오후_8.58.58.png)

https://www.sqlite.org/fileformat2.html#interior_b_tree_pages

SQLite는 페이지 헤더를 위와 같이 저장한다. 페이지 헤더 맨 마지막에 rightmost 포인터를 저장한다.

### Node High keys

가장 오른쪽 포인터를 저장하는 조금 다른 접근법으로 high key와 함께 저장하는 방법도 있다. high key는 현재 노드의 하위 트리에 존재할 수 있는 키 중 가장 높은 키를 이야기한다. 이 접근 방식은 PostgreSQL에서 사용되며 Blink-Trees 라고 이야기한다. 

B-Tree는 N개의 키와 N+1개의 포인터가 존재한다. 각각의 서브트리에서 키는  Ki-1 ≤ Ks < Ki의 값을 가질 수 있다. 

Blink-Tree는 각 노드에 Kn+1 키를 추가한다. 이는 포인터 P(n)이 가리키는 서브트리에 저장할 수 있는 키의 상한을 지정한다. 즉 현재 서브트리에 저장할 수 있는 값의 상한이다. 

![image5.png](attachment:23cb24bd-0912-4255-b31a-3e213d4fc876:스크린샷_2025-06-01_오후_3.19.06.png)

(a)는 high key가 없는 노드를 , (b)는 high key가 있는 노드를 표현했다.

이 경우 포인터와 키가 pair로 저장되고, 각각의 셀이 해당되는 포인터를 가진다. 따라서 엣지 케이스가 줄어들고 rightmost 포인터 처리를 단순화할 수 있다.

![image6.png](attachment:8ac78984-1fc6-4b21-a0dc-d4b47a268116:스크린샷_2025-06-01_오후_3.26.31.png)

두 접근 방식에 대한 대략적인 페이지 구조와 검색 공간이 어떻게 분할되는지 나타낸다.

** high key ** 를 사용하는 방식이 어떻게 구현을 간단화 하는지 고민해보자.

### Overflow Pages

 노드 크기와 트리 팬아웃 값은 고정되어 있으며 동적으로 변경되지 않는다. 또한 가변 크기 값들도 존재하기 때문에 보편적으로 적당한 값을 도출하는 것도 어렵다. 그렇다고 fanout을 너무 작게 잡으면 예약된 공간을 낭비하게 된다.

B-Tree 알고리즘은 모든 노드가 특정 개수 이상의 아이템을 유지하도록 한다. 그러나 가변 크기 값을 저장하는 경우 B-Tree 노드가 포인터 개수가 꽉차진 않았지만 페이지에 여유 공간이 부족해질 수도 있다.

페이지 크기를 동적으로 조정하려면 이미 저장된 데이터를 새로 복사해야 하므로 비현실적인 경우가 많다. 그러나 페이지 크기를 늘리거나 확장할 수 있는 방법을 필요할때가 있다.

값들을 새로 복사하지 않으면서 가변 크기 노드를 구현하려면 여러개의 연결된 페이지로 노드를 구성하는 방법이 있다. 예를 들어 기본 페이지 크기가 4K이고 몇 가지 값을 삽입한 이후 데이터 크기가 4K보다 커진 경우를 생각해보자. 임의의 사이즈를 추가하는 대신 4K의 추가 페이지를 기존 페이지에 연결한다.
이렇게 확장된 페이지를 오버플로우 페이지라고 한다. 명확성을 위해 이 섹션에서 기존 페이지를 primary 페이지. (원본 페이지)라고 부르겠다.

대부분의 B-Tree 구현에서는 고정 크기 페이로드만 노드에 직접 저장하고 나머지 페이지는 오버플로우 페이지에 넘긴다. 이 페이로드 값은 노드 사이즈를 팬아웃으로 나눔으로 계산된다. 이 방식을 사용하면 페이지에 여유 공간이 없는 상황이 거의 발생하지 않으므로 페이지는 항상 `max_payload_size` 바이트 이상을 저장한다. 

삽입된 페이로드가 `max_paload_size` 보다 크다면 노드에 이미 연결된 오버플로우 페이지가 있는지 확인한다. 오버플로우 페이지가 존재하고 공간이 충분하다면 추가 바이트는 오버플로우 페이지로 넘어간다. 그렇지 않다면 세 오버플로우 페이지를 할당한다. 

![image7.png](attachment:1d635deb-88e2-4f1e-85d2-86729d87eba6:스크린샷_2025-06-01_오후_3.57.18.png)

기본 페이지와 오버플로우 페이지를 볼 수 있으며, 기본 페이지에서 페이로드가 계속되는 오버플로우 페이지를 가리키는 레코드가 있다. 

오버 플로우도 기본 페이지와 마찬가지로 파편화될 수 있으므로 세 데이터를 쓰기 전에 빈 공간을 제거하거나, 더 이상 필요해지지 않으면 제거해야한다. 

첫번째 오버플로우 페이지가 할당되면 기본 페이지 헤더에 해당 페이지 ID가 저장된다. 다음 페이지가 추가될때마다 이전 페이지 헤더에 ID를 저장한다. (링크드 리스트 처럼) 주어진 페이로드에 대한 오버플로우 부분을 찾기 위해선 여러 페이지를 탐색해야 할 수도 있다.

키는 카디널리티가 일반적으로 매우 높으므로 키는 일부분만 저장하는 것이 합리적이다. (대부분 비교가 기본 페이지에 잘린 부분으로도 수행 가능하므로)

데이터 레코드는 오버플로우 부분을 찾아서 사용자에게 반환해야 한다. 그러나 이는 빈번하지 않은 작업이므로 크게 중요하지 않다. 모든 데이터 레코드 사이즈가 큰 경우, blob 스토리지를 고려할 필요가 있다.

## Binary Search

---

우리는 이미 B-Tree 조회 알고리즘에 대해 언급한 적이 있으며, 우린 노드 내에서 이진 탐색 알고리즘을 사용해서 키를 검색한다고 언급했다. 이진 탐색은 정렬된 데이터에 대해서만 사용할 수 있다. 따라서 키를 순서대로 유지하고 정렬된 불변 값을 유지하는 것이 필수적이다.

이진 탐색 알고리즘은 정렬된 배열과 검색하려는 키를 받고 숫자를 응답한다. 만약 응답한 숫자가 양수면 검색 키가 정렬된 배열의 몇번째 위치인지를 알려주고, 음수인 경우 검색된 키가 배열에 없으며 삽입해야 할 지점을 알려준다.

삽입 지점은 주어진 키보다 큰 첫번째 요소의 인덱스이다. 이 숫자의 절대값은 정렬을 유지하면서 키를 추가할 수 있는 인덱스이다. 삽입은 삽입 지점에서 시작하여 그보다 큰 값들을 한칸씩 이동하며 수행할 수 있따. 

상위 레벨 검색(초기 검색)은 대부분 일치하지 않으며 어떤 서브트리로 이동해야 하는지 검색 방향을 지정한다. 

### Binary Search with Indirection Pointers

B-Tree 페이지의 셀은 삽입 순서대로 저장되며 셀 오프셋만 논리적인 순서를 유지한다. 페이지 셀들간의 이진 탐색 수행을 위해선 중간 포인터를 찾고, 포인터를 따라가 값을 비교하고, 왼쪽 오른쪽으로 계속 검색할지 결정하는 과정을 재귀적으로 반복해야한다.

## **Propagating Splits and Merges**

---

이전 챕터 설명처럼 B-Tree 분할, 병합은 상위 노드로 전파될 수 있다. 이를 위해 우리는 병합 또는 분할되는 리프 노드에서 루트까지의 체인을 다시 탐색할 수 있어야 한다.

B-Tree 노드는 부모 노드 포인터를 저장할 수도 있다. 그러나 상위에서 하위 레벨로 참조되므로 디스크에 유지할 필요는 없다. (?)

형제 포인터와 마찬가지로 부모 포인터도 부모가 변경될때마다 업데이트되어야 한다. 이는 페이지 식별자가 한 노드에서 다른 노드로 변경되는 모든 경우에 일어난다. (페이지 분할, 병합, 리밸런싱)

일부 구현 (ex: wiredTiger)에선 형제 포인터를 사용하는 중 발생할 수 있는 데드락을 피하기 위해 부모 포인터를 리프 탐색에 사용하기도 한다. 이 알고리즘은 리프 노드를 탐색할때 형제 포인터를 사용하지 않고 부모 포인터를 사용한다.

형제 노드의 주소를 지정하고 탐색하기 위해 우리는 부모 노드의 포인터를 따라가고 재귀적으로 다시 내려오는 방법을 사용할 수 있다. 부모를 공유한는 모든 형제 노드를 탐색한 이후 부모 노드의 끝에 도달하면 재귀적으로 루트 까지 도달했다가 다시 리프 레벨로 내려간다.

### Breadcrumbs

부모 노드 포인터를 저장하고 유지하는 대신, 리프노드로 가는 경로에서 사용한 노드를 저장하고 분할 또는 병합이 발생한 경우 부모 노드 체인을 역순으로 따라 올라갈 수 있다.

B-Tree 구조 변경이 일어날 수 있는 작업(삽입, 삭제)를 수행하는 동안 우리는 먼저 루트에서 리프까지 트리를  탐색하여 대상 노드와 삽입 지점을 찾는다. 작업이 분할, 병합을 일으킬지 모르기 때문에 우리는 빵 부스러기(Breadcrumbs)를 계속 수집해야한다.

Breadcrumbs에는 루트에서 이어지는 노드들에 대한 참조가 들어있으며, 분할 또는 병합의 전파가 일어날때 역으로 추적하기 위해 사용된다. 이를 위한 가장 자연스로운 자료구조는 스택이다. 예를 들어 PostgreSQL은 내부적으로 BTStack이라는 스택에 저장한다.

노드가 분할되거나 병합되는 경우 이 이동경로를 사용하여 부모 노드에 삽입 지점을 찾고 필요한 경우엔 더 위로 거슬러 올라가며 상위 노드로 전파할 수 있다. 이 스택은 메모리에 유지된다.

![image8.png](attachment:5c898960-955d-4ee4-b288-b6033d43dff3:스크린샷_2025-06-01_오후_4.38.26.png)

그림은 방문 노드와 셀 인덱스에 대한 포인터를 포함하는 이동 경로를 수집하는 탐색 예시를 보여준다. 리프 노드가 분할되면 스택 맨 위의 항목부터 팝 되어 상위 노드를 찾아간다. 부모 노드에 충분한 공간이 있으면 세 셀이 추가된다. 그렇지 않으면 부모 노드도 분할된다. 이 프로세스는 스택이 비어 루트에 도달하거나 분할이 없을때까지 재귀적으로 계속된다.